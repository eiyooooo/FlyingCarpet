# Flying Carpet 项目架构详细分析

## 目录
1. [项目概述](#项目概述)
2. [整体架构](#整体架构)
3. [各平台实现逻辑](#各平台实现逻辑)
4. [连接协议详解](#连接协议详解)
5. [数据传输流程](#数据传输流程)
6. [安全机制](#安全机制)
7. [技术栈](#技术栈)

## 项目概述

Flying Carpet 是一个跨平台的文件传输应用，支持在 Android、iOS、Linux、macOS 和 Windows 之间通过 Ad-Hoc WiFi 网络传输文件，无需共享网络或蜂窝连接，仅需要两台具有 WiFi（可选蓝牙）芯片的设备在有效范围内。

### 核心特性
- **跨平台支持**：支持 5 个主流操作系统
- **无需网络基础设施**：使用 WiFi Direct 或热点技术
- **安全传输**：使用 AES-256-GCM 加密
- **蓝牙协商**：支持通过蓝牙 LE 交换连接信息
- **大文件传输**：支持传输大于 2GB 的文件
- **断点续传检测**：自动检测已有文件，避免重复传输

## 整体架构

### 项目结构

```
FlyingCarpet/
├── core/                    # Rust 核心库（跨平台逻辑）
│   ├── src/
│   │   ├── linux/          # Linux 特定实现
│   │   │   ├── network.rs  # Linux 网络管理
│   │   │   ├── bluetooth.rs # Linux 蓝牙实现
│   │   │   ├── central.rs  # BLE 中心设备角色
│   │   │   └── peripheral.rs # BLE 外设角色
│   │   ├── windows/        # Windows 特定实现
│   │   │   ├── network.rs  # Windows 网络管理
│   │   │   ├── bluetooth.rs # Windows 蓝牙实现
│   │   │   ├── central.rs  # BLE 中心设备角色
│   │   │   └── peripheral.rs # BLE 外设角色
│   │   ├── lib.rs          # 核心库入口
│   │   ├── sending.rs      # 发送文件逻辑
│   │   ├── receiving.rs    # 接收文件逻辑
│   │   ├── utils.rs        # 工具函数
│   │   └── error.rs        # 错误处理
│   └── Cargo.toml
├── Flying Carpet/          # 桌面应用（Tauri + Rust）
│   ├── src/                # Web 前端（HTML/CSS/JS）
│   └── src-tauri/          # Tauri 后端（Rust）
├── Android/                # Android 应用（Kotlin）
│   └── FlyingCarpet/
│       └── app/src/main/java/dev/spiegl/flyingcarpet/
│           ├── MainActivity.kt    # 主界面
│           ├── Send.kt           # 发送逻辑
│           ├── Receive.kt        # 接收逻辑
│           ├── Bluetooth.kt      # 蓝牙管理
│           └── Utilities.kt      # 工具函数
└── README.md
```

### 架构设计原则

1. **核心逻辑共享**：使用 Rust 编写跨平台核心库（`core`），Linux、macOS、Windows 桌面版通过 Tauri 框架调用
2. **平台特定实现**：网络和蓝牙功能使用条件编译（`#[cfg_attr]`）针对不同操作系统提供不同实现
3. **异步编程**：大量使用 Tokio 异步运行时，提高性能和响应性
4. **模块化设计**：发送、接收、网络、蓝牙等功能模块独立，便于维护

### 关键抽象

#### 1. UI 特征（Trait）
```rust
pub trait UI: Clone + Send + 'static {
    fn output(&self, msg: &str);
    fn show_progress_bar(&self);
    fn update_progress_bar(&self, percent: u8);
    fn enable_ui(&self);
    fn show_pin(&self, pin: &str);
}
```
这个特征定义了所有平台必须实现的用户界面接口，实现了核心逻辑与 UI 的解耦。

#### 2. 传输模式
```rust
pub enum Mode {
    Send(Vec<PathBuf>),    // 发送模式，包含文件路径列表
    Receive(PathBuf),       // 接收模式，包含目标文件夹路径
}
```

#### 3. 对等设备类型
```rust
pub enum Peer {
    Android,
    IOS,
    Linux,
    MacOS,
    Windows,
}
```

#### 4. 对等资源
```rust
pub enum PeerResource {
    WifiClient(String),                      // 作为客户端连接，包含网关 IP
    WindowsHotspot(network::WindowsHotspot), // Windows 热点
    LinuxHotspot,                            // Linux 热点
}
```

## 各平台实现逻辑

### 1. Windows 平台

#### 网络实现
- **热点创建**：使用 `wifidirect-legacy-ap` 库（基于 Windows WiFi Direct API）
- **网络连接**：使用 `windows-rs` crate 调用 Windows Native WiFi API
- **防火墙管理**：自动添加防火墙规则允许 TCP 连接

**关键实现细节**：
```rust
// 使用 Windows Runtime API 管理 WiFi Direct
use windows::Win32::NetworkManagement::WiFi;
use wifidirect_legacy_ap::WlanHostedNetworkHelper;

pub async fn connect_to_peer<T: UI>(
    peer: Peer,
    mode: Mode,
    ssid: String,
    password: String,
    interface: WiFiInterface,
    ui: &T,
) -> Result<PeerResource, FCError>
```

**防火墙处理**：
- 检查是否已有防火墙规则
- 如果没有，通过 UAC 提示请求管理员权限
- 使用 `netsh` 命令添加规则

**网关发现**：
使用 `IpHelper` API 查找默认网关 IP 地址

#### 蓝牙实现
- **BLE 框架**：使用 Windows Runtime BLE API
- **角色**：
  - **外设（Peripheral）**：发送端作为 GATT 服务器，发布服务和特征
  - **中心（Central）**：接收端作为 GATT 客户端，扫描并连接到外设
- **配对处理**：实现自定义配对回调，通过 UI 线程与用户交互

### 2. Linux 平台

#### 网络实现
- **热点创建**：使用 NetworkManager 的 `nmcli` 命令行工具
- **连接管理**：创建 WiFi 配置文件并激活连接
- **网关发现**：解析 `/proc/net/route` 或使用 `ip route` 命令

**热点配置流程**：
```rust
fn start_hotspot(ssid: &str, password: &str, interface: &str) -> Result<(), FCError> {
    // 1. 添加连接配置
    nmcli con add type wifi ifname <interface> con-name <ssid> ssid <ssid>
    // 2. 设置 AP 模式
    nmcli con modify <ssid> 802-11-wireless.mode ap ipv4.method shared
    // 3. 设置安全和密码
    nmcli con modify <ssid> 802-11-wireless-security.key-mgmt wpa-psk
    nmcli con modify <ssid> 802-11-wireless-security.psk <password>
    // 4. 激活连接
    nmcli con up <ssid>
}
```

**连接到热点**：
```rust
async fn join_hotspot(ssid: &str, password: &str, interface: &str, ui: &T) {
    // 创建临时配置文件连接到热点
}
```

#### 蓝牙实现
- **BLE 框架**：使用 `bluer` 库（基于 BlueZ D-Bus API）
- **适配器管理**：获取默认蓝牙适配器并确保已启用
- **服务发布**：作为外设时，创建 GATT 服务和特征
- **特征读写**：实现异步读写回调

**特征定义**：
```rust
fn get_ssid_characteristic(tx: mpsc::Sender<BluetoothMessage>, ssid: String) -> Characteristic {
    Characteristic {
        uuid: Uuid::parse_str(SSID_CHARACTERISTIC_UUID).unwrap(),
        read: Some(CharacteristicRead {
            read: true,
            secure_read: true,
            fun: Box::new(move |req| {
                // 返回 SSID
            }),
        }),
        write: Some(CharacteristicWrite {
            write: true,
            secure_write: true,
            method: CharacteristicWriteMethod::Fun(Box::new(move |new_value, req| {
                // 接收对端写入的 SSID
            })),
        }),
    }
}
```

### 3. macOS 平台

#### 实现方式
- **代码库**：使用 Swift 编写（不在本仓库中公开）
- **框架**：使用 CoreWLAN 框架管理 WiFi
- **蓝牙**：使用 CoreBluetooth 框架
- **限制**：
  - 无法通过编程方式启动热点（需要用户手动操作）
  - 只能作为连接到热点的客户端（发送时）或接收来自其他平台的连接

#### 蓝牙特殊处理
- macOS 作为外设时，必须由中心设备发起配对
- 与 Linux 配对需要从 macOS 系统菜单手动发起

### 4. iOS 平台

#### 实现方式
- **代码库**：使用 Swift 编写（不在本仓库中公开）
- **框架**：
  - WiFi：使用 NetworkExtension 框架的 NEHotspotConfiguration
  - 蓝牙：使用 CoreBluetooth 框架
- **热点管理**：使用 `LocalOnlyHotspot` API（iOS 13+）
- **限制**：
  - 无法通过编程方式创建热点
  - 只能作为客户端连接到其他设备的热点

### 5. Android 平台

#### 网络实现
- **热点 API**：使用 `LocalOnlyHotspot` API（Android 10+ / API 29+）
- **WiFi 管理**：使用 `WifiManager` 服务
- **权限要求**：
  - `ACCESS_FINE_LOCATION`
  - `ACCESS_WIFI_STATE`
  - `CHANGE_WIFI_STATE`

**热点启动流程**：
```kotlin
wifiManager.startLocalOnlyHotspot(object : WifiManager.LocalOnlyHotspotCallback() {
    override fun onStarted(reservation: WifiManager.LocalOnlyHotspotReservation?) {
        // 获取热点配置（SSID 和密码）
        val ssid = reservation?.wifiConfiguration?.SSID
        val password = reservation?.wifiConfiguration?.preSharedKey
    }
    override fun onFailed(reason: Int) {
        // 处理失败
    }
}, Handler(Looper.getMainLooper()))
```

#### 蓝牙实现
- **BLE 框架**：使用 Android Bluetooth LE API
- **组件**：
  - `BluetoothLeAdvertiser`：发布 BLE 广告
  - `BluetoothLeScanner`：扫描 BLE 设备
  - `BluetoothGattServer`：作为 GATT 服务器
  - `BluetoothGatt`：作为 GATT 客户端

**服务初始化**：
```kotlin
val service = BluetoothGattService(SERVICE_UUID, BluetoothGattService.SERVICE_TYPE_PRIMARY)
service.addCharacteristic(osCharacteristic)
service.addCharacteristic(ssidCharacteristic)
service.addCharacteristic(passwordCharacteristic)
bluetoothGattServer.addService(service)
```

**广告发布**：
```kotlin
val settings = AdvertiseSettings.Builder()
    .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)
    .setConnectable(true)
    .build()
val data = AdvertiseData.Builder()
    .addServiceUuid(ParcelUuid(SERVICE_UUID))
    .build()
bluetoothLeAdvertiser.startAdvertising(settings, data, advertiseCallback)
```

#### 文件传输实现
- **发送**：在 `Send.kt` 中实现，使用 `DocumentFile` 和 `InputStream`
- **接收**：在 `Receive.kt` 中实现，使用 `OutputStream` 写入文件

**分块传输**：
```kotlin
val buffer = ByteArray(chunkSize)  // 1MB
while (bytesLeft > 0) {
    val bytesRead = fileStream.read(buffer)
    bytesLeft -= bytesRead
    encryptAndSendChunk(buffer.sliceArray(0 until bytesRead))
    updateProgress(percentDone)
}
```

### 平台兼容性矩阵

| 发送端 → 接收端 | Android | iOS | Linux | macOS | Windows |
|----------------|---------|-----|-------|-------|---------|
| **Android**    | ✓       | ✓   | ✓     | ✓     | ✓       |
| **iOS**        | ✓       | ✗   | ✓     | ✗     | ✓       |
| **Linux**      | ✓       | ✓   | ✓     | ✓     | ✓       |
| **macOS**      | ✓       | ✗   | ✓     | ✗     | ✓       |
| **Windows**    | ✓       | ✓   | ✓     | ✓     | ✓       |

注：✗ 表示应使用 AirDrop 替代

## 连接协议详解

### 1. WiFi 连接协议

#### WiFi Direct / 热点模式
Flying Carpet 使用 WiFi Direct（或传统热点）创建点对点连接。

**SSID 生成规则**：
```rust
pub fn get_key_and_ssid(password: &str) -> ([u8; 32], String) {
    let mut hasher = Sha256::new();
    hasher.update(password.as_bytes());
    let key = hasher.finalize();
    let ssid = format!("flyingCarpet_{:02x}{:02x}", key[0], key[1]);
    (key.into(), ssid)
}
```
- SSID 格式：`flyingCarpet_XX` 其中 XX 是密码哈希的前两个字节（十六进制）
- 密钥：SHA-256(password) 的 32 字节输出

**连接建立流程**：

1. **确定角色**：
   ```rust
   pub fn is_hosting(peer: &Peer, mode: &Mode) -> bool {
       match peer {
           Peer::Android | Peer::IOS | Peer::MacOS => true,  // 总是主机
           Peer::Windows => false,                            // 总是客户端
           Peer::Linux => match mode {
               Mode::Send(_) => false,    // 发送时作为客户端
               Mode::Receive(_) => true,  // 接收时作为主机
           },
       }
   }
   ```

2. **主机端（Hosting）**：
   - 创建 WiFi 热点
   - 设置 SSID 和密码
   - 配置 IP 地址（通常为 192.168.137.1 或 192.168.49.1）
   - 启动 TCP 服务器监听端口 3290

3. **客户端（Joining）**：
   - 扫描并连接到指定 SSID 的热点
   - 输入密码完成认证
   - 获取 DHCP 分配的 IP 地址
   - 查找网关 IP（即主机的 IP）
   - 连接到主机的 TCP 端口 3290

#### IP 地址和端口
- **TCP 端口**：3290（硬编码）
- **主机 IP**：
  - Windows：192.168.137.1
  - Linux：192.168.4.1 或由 NetworkManager 分配
  - Android：通过 `LocalOnlyHotspot` API 获取

### 2. 蓝牙 LE 协议

Flying Carpet 使用蓝牙低能耗（BLE）技术交换 WiFi 连接信息，包括对端操作系统、SSID 和密码。

#### BLE 服务和特征定义

**服务 UUID**：`A70BF3CA-F708-4314-8A0E-5E37C259BE5C`

**特征 UUID**：
1. **OS 特征**：`BEE14848-CC55-4FDE-8E9D-2E0F9EC45946`
   - 用途：交换操作系统信息
   - 权限：可读、可写、需要加密
   - 值：字符串 "android"、"ios"、"linux"、"mac"、"windows"

2. **SSID 特征**：`0D820768-A329-4ED4-8F53-BDF364EDAC75`
   - 用途：交换 WiFi SSID
   - 权限：可读、可写、需要加密
   - 值：SSID 字符串或 "NONE"（表示不使用蓝牙）

3. **Password 特征**：`E1FA8F66-CF88-4572-9527-D5125A2E0762`
   - 用途：交换 WiFi 密码
   - 权限：可读、可写、需要加密
   - 值：密码字符串

#### 蓝牙角色

**发送端（Sender）** → **BLE 外设（Peripheral / GATT Server）**：
- 发布 BLE 广告，包含服务 UUID
- 创建 GATT 服务器，注册上述特征
- 等待接收端连接
- 响应特征读取请求（返回本地 SSID 和密码）
- 接收特征写入请求（获取对端操作系统）

**接收端（Receiver）** → **BLE 中心（Central / GATT Client）**：
- 扫描包含指定服务 UUID 的 BLE 设备
- 连接到发送端的 GATT 服务器
- 发现服务和特征
- 写入本地操作系统到 OS 特征
- 读取 SSID 和 Password 特征
- 断开连接

#### 蓝牙协商流程

```
发送端（Peripheral）                     接收端（Central）
    |                                          |
    |--- 1. 发布广告（包含 SERVICE_UUID）----->|
    |                                          |
    |<---------- 2. 扫描并连接 -----------------|
    |                                          |
    |<-------- 3. 发现服务和特征 ---------------|
    |                                          |
    |<-- 4. 写入 OS 特征（"android"/"linux"）---|
    |                                          |
    |--- 5. 读取 SSID 特征 -------------------->|
    |--- 6. 返回 SSID("flyingCarpet_xx") ----->|
    |                                          |
    |<-- 7. 读取 Password 特征 -----------------|
    |--- 8. 返回 Password("xxxxxxxx") -------->|
    |                                          |
    |<----------- 9. 断开连接 ------------------|
    |                                          |
```

完成蓝牙协商后，双方都知道：
- 对端操作系统类型
- WiFi SSID 和密码
- 谁应该创建热点，谁应该连接

#### 配对和加密
- **加密要求**：所有特征都标记为 `secure_read` 和 `secure_write`
- **配对流程**：
  - 首次连接时，系统会触发配对请求
  - 用户需要确认 PIN 码或批准配对
  - 配对成功后，特征读写才会被允许
- **平台差异**：
  - Windows：实现自定义配对处理器，通过 UI 显示 PIN 码
  - Linux：使用 BlueZ 的配对代理
  - Android：系统自动显示配对对话框
  - macOS/iOS：系统处理配对 UI

### 3. TCP 传输协议

建立 WiFi 连接后，Flying Carpet 使用 TCP 协议传输文件数据。

#### TCP 连接建立

**服务器端（主机）**：
```rust
let listener = TcpListener::bind(format!("0.0.0.0:{}", PORT)).await?;
let (mut stream, addr) = listener.accept().await?;
```

**客户端**：
```rust
let mut stream = TcpStream::connect(format!("{}:{}", gateway_ip, PORT)).await?;
```

#### 协议消息格式

所有整数均使用**大端序（Big-Endian）**编码。

##### 1. 初始握手
```
客户端 → 服务器: 主版本号 (u64, 8 bytes)
服务器 → 客户端: 主版本号 (u64, 8 bytes)
```
当前主版本号为 9（`MAJOR_VERSION = 9`）。

##### 2. 文件传输协议

**发送端流程**：
```
For each file:
    1. 发送文件名长度 (u64)
    2. 发送文件名字节 (UTF-8)
    3. 发送文件大小 (u64)
    4. 接收确认 (u64): 0 = 需要传输, 1 = 已存在跳过
    
    If 需要传输:
        While file has data:
            5. 发送加密块大小 (u64)
            6. 发送加密块数据 (nonce + ciphertext)
        7. 发送块大小 0 (u64) 表示文件结束
        8. 接收确认 (u64)
    9. 发送最终确认 (u64)
```

**接收端流程**：
```
For each file:
    1. 接收文件名长度 (u64)
    2. 接收文件名字节
    3. 接收文件大小 (u64)
    4. 检查文件是否已存在，发送确认 (u64)
    
    If 需要传输:
        While true:
            5. 接收加密块大小 (u64)
            If 块大小 == 0: break
            6. 接收加密块数据
            7. 解密并写入文件
        8. 发送确认 (u64)
    9. 接收最终确认 (u64)
```

##### 3. 加密块格式
```
[Nonce: 12 bytes] [Ciphertext: variable] [Tag: 16 bytes]
```
- **Nonce**：96 位随机数，每个块不同
- **Ciphertext**：AES-256-GCM 加密的数据块
- **Tag**：128 位认证标签（GCM 模式内置）

实际上，`aes-gcm` crate 的 `encrypt` 方法返回的是 `ciphertext || tag`，所以接收端需要处理整个加密输出。

##### 4. 文件名处理
- **路径分隔符**：统一使用 `/`（Windows 上从 `\` 转换）
- **相对路径**：发送文件夹时，保留文件夹结构
- **冲突处理**：如果文件已存在，在文件名前添加 `(1) `、`(2) ` 等前缀

## 数据传输流程

### 完整传输流程

#### 阶段 1：初始化和配对

1. **用户操作**：
   - 发送端：选择文件或文件夹，选择对端平台，选择是否使用蓝牙
   - 接收端：选择保存文件夹，选择对端平台，选择是否使用蓝牙

2. **密码生成**（如果使用蓝牙）：
   ```rust
   pub fn generate_password() -> String {
       // 生成 8 位随机密码，字符集: 2-9, a-z (除 l), A-Z (除 I, O)
   }
   ```

3. **蓝牙协商**（如果启用）：
   - 发送端和接收端通过 BLE 交换信息
   - 确定对端操作系统
   - 交换 SSID 和密码

4. **手动输入**（如果禁用蓝牙）：
   - 一端显示生成的密码和 SSID
   - 另一端用户手动输入或扫描 QR 码

#### 阶段 2：网络连接

5. **确定角色**：
   - 根据对端平台和传输模式决定谁创建热点

6. **建立热点**（主机端）：
   - 创建 WiFi 热点
   - 等待客户端连接

7. **连接热点**（客户端）：
   - 扫描并连接到热点
   - 获取 IP 地址
   - 查找网关 IP

#### 阶段 3：TCP 连接

8. **服务器监听**（通常是发送端）：
   ```rust
   let listener = TcpListener::bind("0.0.0.0:3290").await?;
   let (stream, _) = listener.accept().await?;
   ```

9. **客户端连接**（通常是接收端）：
   ```rust
   let stream = TcpStream::connect(format!("{}:3290", gateway_ip)).await?;
   ```

10. **版本协商**：
    - 双方交换主版本号
    - 如果版本不匹配，中止传输

#### 阶段 4：文件传输

11. **发送端逻辑**（对每个文件）：
    ```rust
    pub async fn send_file<T: UI>(
        file: &Path,
        prefix: &Path,
        key: &[u8],
        stream: &mut TcpStream,
        ui: &T,
    ) -> Result<(), FCError>
    ```
    - 发送文件详情（文件名、大小）
    - 检查接收端是否已有该文件
    - 如果需要传输：
      - 分块读取文件（1MB 块）
      - 加密每个块（AES-256-GCM）
      - 发送加密块
      - 更新进度条
    - 发送结束标志（块大小 0）
    - 等待确认

12. **接收端逻辑**（对每个文件）：
    ```rust
    pub async fn receive_file<T: UI>(
        folder: &Path,
        key: &[u8],
        stream: &mut TcpStream,
        ui: &T,
        last_file: bool,
    ) -> Result<(), FCError>
    ```
    - 接收文件详情
    - 检查本地是否已有该文件（通过哈希）
    - 如果需要传输：
      - 创建目标文件
      - 循环接收加密块
      - 解密并写入文件
      - 更新进度条
    - 发送确认

#### 阶段 5：清理

13. **关闭连接**：
    - 关闭 TCP 流
    - 关闭热点
    - 恢复原有网络连接

14. **显示统计**：
    - 传输时间
    - 传输速度（Mbps）

### 发送流程详解

```rust
async fn encrypt_and_send_chunk(
    chunk: &[u8],
    cipher: &Aes256Gcm,
    stream: &mut TcpStream,
) -> Result<(), FCError> {
    // 1. 生成随机 nonce（96 位）
    let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
    
    // 2. 加密数据块
    let ciphertext = cipher.encrypt(&nonce, chunk)
        .map_err(|_| fc_error("Encryption error"))?;
    
    // 3. 组合 nonce 和 ciphertext
    let encrypted_chunk = [nonce.as_slice(), ciphertext.as_slice()].concat();
    
    // 4. 发送块大小（大端序 u64）
    stream.write_u64(encrypted_chunk.len() as u64).await?;
    
    // 5. 发送加密块
    stream.write_all(&encrypted_chunk).await?;
    
    Ok(())
}
```

### 接收流程详解

```rust
async fn receive_and_decrypt_chunk(
    cipher: &Aes256Gcm,
    stream: &mut TcpStream,
) -> Result<Vec<u8>, FCError> {
    // 1. 读取块大小
    let chunk_size = stream.read_u64().await? as usize;
    
    // 2. 如果块大小为 0，表示文件传输结束
    if chunk_size == 0 {
        return Ok(vec![]);
    }
    
    // 3. 读取加密块
    let mut encrypted_chunk = vec![0u8; chunk_size];
    stream.read_exact(&mut encrypted_chunk).await?;
    
    // 4. 分离 nonce 和 ciphertext
    let nonce = Nonce::from_slice(&encrypted_chunk[..12]);
    let ciphertext = &encrypted_chunk[12..];
    
    // 5. 解密
    let plaintext = cipher.decrypt(nonce, ciphertext)
        .map_err(|_| fc_error("Decryption error"))?;
    
    Ok(plaintext)
}
```

### 文件完整性检查

**发送端**：
```rust
async fn check_for_file(file: &Path, stream: &mut TcpStream) -> Result<bool, FCError> {
    // 计算文件 SHA-256 哈希
    let hash = hash_file(file)?;
    
    // 接收接收端的响应
    let response = stream.read_u64().await?;
    
    Ok(response == 0)  // 0 = 需要传输, 1 = 跳过
}
```

**接收端**：
```rust
async fn check_for_file(
    full_path: &Path,
    file_size: u64,
    stream: &mut TcpStream,
) -> Result<bool, FCError> {
    if !full_path.exists() {
        // 文件不存在，需要传输
        stream.write_u64(0).await?;
        return Ok(true);
    }
    
    // 检查文件大小
    let metadata = fs::metadata(full_path)?;
    if metadata.len() != file_size {
        stream.write_u64(0).await?;
        return Ok(true);
    }
    
    // 计算本地文件哈希（如果实现）
    // 这里简化为只检查大小
    
    // 文件已存在，跳过传输
    stream.write_u64(1).await?;
    Ok(false)
}
```

## 安全机制

### 1. 加密算法

Flying Carpet 使用 **AES-256-GCM** 对传输的文件数据进行加密。

#### AES-256-GCM 特性
- **密钥长度**：256 位（32 字节）
- **模式**：Galois/Counter Mode（GCM）
- **认证加密**：同时提供机密性和完整性
- **Nonce 长度**：96 位（12 字节）
- **标签长度**：128 位（16 字节）

#### 密钥派生
```rust
pub fn get_key_and_ssid(password: &str) -> ([u8; 32], String) {
    let mut hasher = Sha256::new();
    hasher.update(password.as_bytes());
    let key = hasher.finalize();  // 256 位密钥
    let ssid = format!("flyingCarpet_{:02x}{:02x}", key[0], key[1]);
    (key.into(), ssid)
}
```

**注意**：使用 SHA-256 而非 PBKDF2/Scrypt/Argon2 的原因：
- 密钥仅在单次传输期间使用
- 攻击者需要在热点网络上（受 WPA2 保护）
- 跨平台实现的简化

### 2. 密码生成

```rust
pub fn generate_password() -> String {
    let chars: Vec<char> = "23456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        .chars()
        .collect();
    // 生成 8 位随机密码
}
```

**字符集选择**：
- 排除了容易混淆的字符（0, 1, I, O, l）
- 包含数字、小写和大写字母
- 熵：log₂(57^8) ≈ 46 位

### 3. Nonce 管理

每个加密块使用唯一的随机 nonce：
```rust
let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
```

**关键点**：
- 使用操作系统的加密安全随机数生成器（`OsRng`）
- 每个块的 nonce 不同，避免 nonce 重用攻击
- 96 位 nonce 空间足够大，碰撞概率极低

### 4. 网络安全

#### WPA2 保护
- WiFi 热点使用 WPA2-PSK 加密
- 提供额外的网络层保护
- 防止未授权设备加入热点

#### 本地网络隔离
- 使用 `LocalOnlyHotspot`（Android）或类似机制
- 创建的热点不提供互联网访问
- 限制了潜在的攻击面

### 5. 蓝牙安全

#### 配对和加密
- 使用 BLE Secure Connections（如果支持）
- 所有特征标记为 `secure_read` 和 `secure_write`
- 需要配对才能访问特征

#### PIN 码验证
- 用户必须确认 PIN 码匹配
- 防止中间人攻击

### 6. 数据完整性

#### GCM 认证标签
- 每个加密块包含 128 位认证标签
- 检测数据篡改或损坏
- 如果验证失败，解密操作会返回错误

#### 文件哈希（部分实现）
- 提供 `hash_file` 函数计算 SHA-256 哈希
- 可用于跳过已传输的文件
- 可扩展用于端到端文件完整性验证

### 7. 防火墙管理（Windows）

Windows 平台自动管理防火墙规则：
```rust
fn add_firewall_rule() -> Option<String> {
    // 使用 netsh 添加入站规则
    // 允许 TCP 端口 3290
    // 需要管理员权限（UAC 提示）
}
```

### 8. 安全考虑和限制

#### 威胁模型
- **假设**：传输发生在物理接近的两台设备之间
- **保护目标**：防止附近的被动窃听者
- **不保护**：不防御复杂的主动攻击或长期密钥泄露

#### 已知限制
1. **密钥派生**：SHA-256 不如 PBKDF2，但在此场景下可接受
2. **前向安全**：密钥重用时无前向安全性
3. **身份验证**：依赖用户验证 PIN 码或 QR 码
4. **侧信道**：未专门防御时序或功耗分析攻击

#### 安全建议
- 在私密环境中使用
- 验证蓝牙 PIN 码
- 使用强密码（如果手动输入）
- 传输完成后删除敏感文件

## 技术栈

### 核心库（Rust）

#### 主要依赖
```toml
[dependencies]
aes-gcm = "0.10"              # AES-256-GCM 加密
futures = "0.3.31"            # 异步编程基础
rand = "0.8"                  # 随机数生成
regex = "1"                   # 正则表达式
serde = { version = "1.0", features = ["derive"] }  # 序列化/反序列化
sha2 = { version = "0.10" }   # SHA-256 哈希
tokio = { version = "1", features = ["full"] }  # 异步运行时
wifidirect-legacy-ap = "0.4.0"  # Windows WiFi Direct API

[target.'cfg(unix)'.dependencies]
bluer = { version = "0.17.3", features = ["bluetoothd"] }  # Linux 蓝牙（BlueZ）

[target.'cfg(windows)'.dependencies.windows]
version = "0.58.0"
features = [
    "Devices_Bluetooth",               # 蓝牙 API
    "Devices_Bluetooth_Advertisement",
    "Devices_Bluetooth_GenericAttributeProfile",
    "Win32_NetworkManagement_WiFi",    # WiFi 管理
    # ... 其他 Windows API
]
```

### 桌面应用（Tauri）

#### 前端
- **HTML5**：界面结构
- **CSS3**：样式设计
- **JavaScript**：交互逻辑
- **依赖**：
  - QR 码生成库
  - 文件选择器

#### 后端（Rust）
```toml
[dependencies]
flying-carpet-core = { path = "../../core" }  # 核心库
tauri = { version = "2", features = ["..." ] }  # Tauri 框架
tokio = { version = "1", features = ["full"] }
```

**Tauri 命令**：
- `start_transfer`：启动文件传输
- `cancel_transfer`：取消传输
- `get_wifi_interfaces`：获取网络接口列表
- `check_bluetooth_support`：检查蓝牙支持
- `respond_to_pair`：响应蓝牙配对请求

### Android 应用（Kotlin）

#### 构建系统
- **Gradle**：构建工具
- **Android Gradle Plugin**：Android 构建支持
- **Kotlin Gradle Plugin**：Kotlin 编译支持

#### 核心依赖
```gradle
dependencies {
    implementation "androidx.core:core-ktx:1.x.x"
    implementation "androidx.appcompat:appcompat:1.x.x"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.x.x"
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.x.x"
    implementation "androidx.documentfile:documentfile:1.x.x"
    implementation "com.google.android.material:material:1.x.x"
    implementation "com.journeyapps:zxing-android-embedded:4.x.x"  // QR 码扫描
}
```

#### 架构
- **MVVM 模式**：`MainActivity` + `MainViewModel`
- **LiveData**：响应式数据绑定
- **Coroutines**：异步操作

#### 主要组件
```kotlin
MainActivity.kt          // 主界面和用户交互
MainViewModel.kt         // 业务逻辑和状态管理
Send.kt                  // 发送文件逻辑
Receive.kt               // 接收文件逻辑
Bluetooth.kt             // 蓝牙管理
Utilities.kt             // 工具函数（加密、哈希等）
```

### iOS/macOS 应用（Swift）

#### 框架
- **SwiftUI** 或 **UIKit**（iOS）
- **AppKit**（macOS）
- **CoreWLAN**：WiFi 管理
- **CoreBluetooth**：蓝牙 LE
- **Network.framework**：网络连接
- **CryptoKit**：加密操作

#### 注意
iOS 和 macOS 的代码不在此仓库中公开。

### 开发工具

#### Rust 生态
- **rustc**：Rust 编译器（1.70+）
- **cargo**：包管理器和构建工具
- **cargo-tauri**：Tauri CLI 工具

#### Android 开发
- **Android Studio**：IDE
- **Android SDK**：开发工具包（API 29+）
- **Kotlin**：编程语言（1.8+）

#### 其他工具
- **Git**：版本控制
- **GitHub Actions**：CI/CD
- **Fastlane**：自动化发布（Android）

### 平台特定 API

#### Linux
- **NetworkManager**（通过 `nmcli`）：WiFi 管理
- **BlueZ**（通过 D-Bus）：蓝牙栈
- **iproute2**：网络配置

#### Windows
- **Windows Runtime API**：现代 Windows API
- **Win32 API**：传统 Windows API
- **WinRT Bluetooth LE API**：蓝牙低能耗
- **Native WiFi API**：WiFi 管理
- **Windows Firewall API**：防火墙管理

#### macOS
- **CoreWLAN**：WiFi 扫描和连接
- **CoreBluetooth**：蓝牙 LE
- **NEHotspotConfiguration**：热点配置（受限）

#### Android
- **WifiManager**：WiFi 管理
- **LocalOnlyHotspot API**：本地热点
- **Bluetooth LE API**：蓝牙低能耗
- **Storage Access Framework**：文件访问

#### iOS
- **NetworkExtension**：网络扩展
- **CoreBluetooth**：蓝牙 LE
- **Personal Hotspot API**：热点管理（受限）

## 代码组织和模式

### 条件编译

使用 Rust 的 `cfg` 属性实现平台特定代码：

```rust
#[cfg_attr(target_os = "linux", path = "linux/network.rs")]
#[cfg_attr(target_os = "windows", path = "windows/network.rs")]
pub mod network;

#[cfg_attr(target_os = "linux", path = "linux/bluetooth.rs")]
#[cfg_attr(target_os = "windows", path = "windows/bluetooth.rs")]
pub mod bluetooth;
```

这允许为不同平台提供不同的实现，同时保持相同的公共接口。

### 错误处理

自定义错误类型：
```rust
pub struct FCError {
    pub message: String,
}

impl From<std::io::Error> for FCError {
    fn from(value: std::io::Error) -> Self {
        FCError { message: value.to_string() }
    }
}
```

统一的错误处理使跨平台代码更容易维护。

### 异步编程

广泛使用 Tokio 异步运行时：
```rust
pub async fn start_transfer<T: UI>(
    mode: String,
    using_bluetooth: bool,
    peer: Option<String>,
    password: Option<String>,
    // ...
) -> Result<(), FCError>
```

**优势**：
- 非阻塞 I/O
- 高并发性能
- 清晰的异步代码结构

### UI 抽象

通过 `UI` trait 实现 UI 解耦：
```rust
pub trait UI: Clone + Send + 'static {
    fn output(&self, msg: &str);
    fn show_progress_bar(&self);
    fn update_progress_bar(&self, percent: u8);
    fn enable_ui(&self);
    fn show_pin(&self, pin: &str);
}
```

不同平台实现此 trait：
- **Tauri**：通过事件系统发送消息到 JavaScript 前端
- **Android**：通过 LiveData 更新 UI
- **iOS/macOS**：通过闭包或委托模式

## 性能优化

### 分块传输

使用 1MB 的块大小平衡内存使用和性能：
```rust
const CHUNKSIZE: usize = 1_000_000; // 1 MB
```

**权衡**：
- 更大的块：更少的加密开销，更高的内存使用
- 更小的块：更频繁的加密调用，更及时的进度更新

### 异步 I/O

所有文件和网络操作都是异步的，避免阻塞：
```rust
tokio::io::AsyncReadExt::read_exact(&mut stream, &mut buffer).await?;
tokio::io::AsyncWriteExt::write_all(&mut stream, &data).await?;
```

### 并发任务

使用 `tokio::spawn` 并发处理多个任务：
- 蓝牙协商
- 网络连接
- 文件传输
- UI 更新

### 零拷贝优化

直接操作字节缓冲区，减少内存复制：
```rust
let encrypted_chunk = [nonce.as_slice(), ciphertext.as_slice()].concat();
stream.write_all(&encrypted_chunk).await?;
```

## 总结

Flying Carpet 是一个设计精巧的跨平台文件传输应用，巧妙地结合了多种技术：

1. **跨平台架构**：使用 Rust 实现核心逻辑，通过条件编译适配不同平台
2. **多协议支持**：WiFi Direct、蓝牙 LE、TCP 协同工作
3. **安全传输**：AES-256-GCM 加密保护数据机密性和完整性
4. **用户友好**：自动化网络配置，蓝牙协商简化使用流程
5. **高性能**：异步 I/O、分块传输、并发处理

该项目展示了如何在保持代码可维护性的同时，处理复杂的平台特定 API 和网络协议。通过清晰的模块划分和抽象，Flying Carpet 成功地在多个平台上提供了一致的用户体验。

---

**文档版本**：基于 Flying Carpet v9.0  
**最后更新**：2025-11-23  
**作者**：根据源代码分析生成
